---
title: "Sc analysis"
author: "Luisa Santus"
date: "1/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(Seurat)
library(Matrix)
library(scater)
library(SingleCellExperiment)
library(purrr)
library(stringr)
library(mvoutlier)

source("utils/sc_utils.R")
```
## Single Cell Analysis


```{r cars}
# Load the PBMC dataset
library(Seurat)
library(stringr)
data_dir <- "/home/luisas/Desktop/cluster/data/01_Ebola-RNASeq/03_scRNA-Seq/01_digital_expression/"

# --------------------------
#  Create Seurats Object
# --------------------------
list <- lapply(iterate_files(data_dir, "dge.txt.gz"), function(x) as.matrix(read.table(x)))
m <- as.matrix(read.table(iterate_files(data_dir, "dge.txt.gz")))
mm2 <- matrix(m, ncol = ncol(file), dimnames = NULL)
# Assign rownames and colnames and drop first row and column.
rownames(mm2) <- mm2[,1]; colnames(mm2) <- mm2[1,]
mm2 <- mm2[,-1]; mm2 <- mm2[-1,]
# Creates dgCMatrix for creating seurats object
counts_matrix <- as(mm2, "dgCMatrix")
# Should show barcodes.tsv, genes.tsv, and matrix.mtx
pbmc <- CreateSeuratObject(counts = counts_matrix, project = "scEbola")
```


Obtain stats
```{r cars}
# --------------------------
#  Obtain stats
# --------------------------

# get mitochondrial percentages!!
#pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")

dim(pbmc)
vln <- VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA"), ncol = 2, pt.size=0)
vln
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot2

ggsave(file.path(data_dir, "plots/ncountVSpercentmt.png"), plot1 ) 
ggsave(file.path(data_dir, "plots/ncountVSfeature.png"), plot2 ) 
ggsave(file.path(data_dir, "plots/combo.png"), combo ) 
ggsave(file.path(data_dir, "plots/violin.png"), vln ) 
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}

pbmc_sc <- as.SingleCellExperiment(pbmc)
pbmc_sc <- calculateQCMetrics(pbmc_sc)
```
# plots
```{r}
# Library size
lib_size_hist <- plot_histogram(
  sce = pbmc_sc, 
  qc_metric = "total_counts", 
  title = "Library Size (total UMI)", 
  log_scale = TRUE
)

# Number of detected genes
n_detec_hist <- plot_histogram(
  sce = pbmc_sc, 
  qc_metric = "total_features_by_counts", 
  title = "Number of detected genes", 
  log_scale = FALSE
)


lsizeplot <- lib_size_hist +
  geom_vline(xintercept = c(1500, 10000), linetype = "dashed", color = "red")
ndectplot <- n_detec_hist +
  geom_vline(xintercept = c(500, 2000), linetype = "dashed", color = "red")

lsizeplot
ndectplot

```

We can proceed with the filtering:

```{r}
pbmc <- pbmc_sc
keep_cells <-
  pbmc$total_counts > 1500 & pbmc$total_counts < 10000 &
  pbmc$total_features_by_counts > 500 & pbmc$total_features_by_counts < 2000 
table(keep_cells)
```

Let us assess if poor-quality cells cluster together

```{r}
pbmc <- runTSNE(pbmc, exprs_values = "counts")
pbmc$poor_quality <- !keep_cells
tsne_poor <- reducedDim(pbmc) %>% 
  as.data.frame() %>% 
  set_names(c("tSNE1", "tSNE2")) %>% 
  mutate(is_poor_quality = pbmc$poor_quality) %>% 
  ggplot(aes(tSNE1, tSNE2, color = is_poor_quality)) +
    geom_point() +
    scale_color_manual("lysed cells", values = c("gray62", "red2")) +
    theme_classic2()
tsne_poor
```


Filter cells:

```{r}
pbmc <- pbmc[, keep_cells]
```


## Gene QC
Let us compute the number of cells that each gene has at least 1 UMI:

```{r}
n_cells <- rowSums(as.matrix(counts(pbmc)) > 0)
gene_qc_gg <- n_cells %>% 
  as.data.frame() %>% 
  ggplot(aes(n_cells)) + 
    geom_histogram(bins = 100, alpha = 0.75) +
    scale_x_log10("log10(Number of cells)") +
    theme_bw() 
gene_qc_gg
```

We see two peaks, the firt one of which corresponds to lowly expressed genes. As explained in [Luecken MD et al.](https://www.embopress.org/doi/pdf/10.15252/msb.20188746): "a guideline to setting this threshold is to use the minimum cell cluster size that is of interest and leaving some leeway for dropout effects". As we will not rely on clusters that have fewer than 15 cells, we will use it as a filter:

```{r}
pbmc <- pbmc[n_cells > 15, ]
pbmc
```

### Identify highly expressed genes
As a validation, let us check whether the highest expressed genes are housekeeping genes like ACTB:

```{r}
plotHighestExprs(pbmc)
```

# Normalization
To normalize for differences in library size and RNA composition, we will use the `scran` package:

```{r}
library(scran)
pbmc <- computeSumFactors(pbmc)
summary(sizeFactors(pbmc))
pbmc <- normalize(pbmc)
assays(pbmc)
logcounts(pbmc)[1:6, 1:6]
plot(sizeFactors(pbmc) ~ pbmc$total_counts)
```

## Save

```{r}
saveRDS(pbmc, "results/R_objects/external_dataset_SCE.rds")
```

# Seurat

```{r}
# Convert to Seurat object
pbmc_seu <- as.Seurat(pbmc)

# Seurat pre-processing pipeline
pbmc_seu <- FindVariableFeatures(pbmc_seu)
pbmc_seu <- ScaleData(pbmc_seu)
pbmc_seu <- RunPCA(pbmc_seu)
ElbowPlot(pbmc_seu)
pbmc_seu <- FindNeighbors(pbmc_seu, reduction = "pca", dims = 1:6)
pbmc_seu <- FindClusters(pbmc_seu, resolution = 0.1)
pbmc_seu <- RunUMAP(pbmc_seu, reduction = "pca", dims = 1:6)
DimPlot(pbmc_seu, reduction = "umap")

# Save Seurat
saveRDS(pbmc_seu, "results/R_objects/external_dataset_Seurat.rds")
pbmc_seu <- readRDS("results/R_objects/external_dataset_Seurat.rds")
```

Find markers:

```{r}
markers <- FindAllMarkers(
  pbmc_seu, 
  features = pbmc_seu@assays$RNA@var.features, 
  min.pct = 0.25
)

library(dplyr)
map(unique(markers$cluster), function(k) {
  markers %>% 
    dplyr::filter(cluster == k) %>% 
    head(30) %>% 
    select("cluster", "gene", "avg_logFC")
})
```

Judging by the previous markers, we can annotate the clusters as follows:

Cluster ID | Markers       | Cell Type
-----------|---------------|----------
0          | IL7R          | CD4 T cells
1          | CD8A          | CD8 T cells
2          | GNLY, NKG7    | Natural Killer (NK)
3          | LYZ, S100A8   | CD14+ Monocytes
4          | MS4A1, CD79A  | B cells
5          | FCGR3A        | FCGR3A+ Monocytes

We can visualize these markers in UMAP space:

```{r}
clust_markers <- c("ENSMMUG00000014381--GZMB", "ENSMMUG00000002122--SPOCK2", "ENSMMUG00000006880--CD19", "ENSMMUG00000019304--IDO1")

FeaturePlot(pbmc_seu, features = clust_markers, reduction = "umap")
```

Finally, we can label clusters to its cell type:

```{r}
new_cluster_ids <- c("CD4 T", "CD8 T", "NK", "CD14+ Mono")
names(new_cluster_ids) <- levels(pbmc_seu)
pbmc_seu <- RenameIdents(pbmc_seu, new_cluster_ids)
DimPlot(pbmc_seu, reduction = "umap")
```

# Score cells based on sampling time signature

```{r}
# Load PBMC type-specific sampling time signature
metasignature <- readRDS(file = "results/R_objects/metasignatures.rds")
signatures_df <- readRDS(file = "results/R_objects/gene_signatures.rds")

# Join CD14+ and FCGR3A+ into a single  monocyte cluster
pbmc_seu$cell_type <- Idents(pbmc_seu)
cell_type2 <- str_replace(pbmc_seu$cell_type, ".*Mono$", "Monocyte")
pbmc_seu$cell_type2 <- cell_type2

# Pre-process meta-signature data frames:
rankings_list <- list()
for (type in names(metasignature)) {
  rankings <- map_dbl(metasignature[[type]], function(g) {
    ranking <- mean(map_dbl(signatures_df[[type]], ~ which(.[!.$is_random, "gene"] == g)))
  })
  names(rankings) <- metasignature[[type]]
  rankings_list[[type]] <- sort(rankings)
}

rankings_dfs <- map(names(rankings_list), function(type) {
  gene_vect <- names(rankings_list[[type]])
  index_gene_vect <- match(gene_vect, signatures_df[[type]][[1]]$gene)
  signature_df_sub <- signatures_df[[type]][[1]][index_gene_vect, ]
  sign_vect <- sign(signature_df_sub$log_fc)
  df <- data.frame(gene = gene_vect, sign = sign_vect)
  df
})
names(rankings_dfs) <- names(rankings_list)

# Calculate time-score for every cell in SCE
seu_list <- SplitObject(pbmc_seu, split.by = "cell_type2")
sce_list <- map(seu_list, as.SingleCellExperiment)
sce_list <- sce_list[names(metasignature)]
sce_list <- map2(
  sce_list, rankings_dfs, 
  ~ calc_time_score_v3(sce = .x, signature_df = .y, random = FALSE)
)

# Input time_score to metadata
cell_names_sce <- map(sce_list, colnames)
cell_names_sce <- Reduce(c, cell_names_sce)
time_scores <- map(sce_list, ~ .$time_score)
time_scores <- Reduce(c, time_scores)
time_score_df <- data.frame(barcode = cell_names_sce, time_score = time_scores)
rownames(time_score_df) <- time_score_df$barcode
time_score_df <- time_score_df[colnames(pbmc_seu), ]
pbmc_seu$time_score <- time_score_df$time_score

# Visualize time-score in UMAP space
FeaturePlot(pbmc_seu, features = "time_score") + scale_colour_gradient2()
```


We see that for each cluster, cells segregate by time-score. To validate that this is indeed the signal of sampling time, let us repeat the same process with a reference dataset that was obtained using fresh cells (male_04 from previous analysis):

```{r}
# Load SingleCellExperiment object
pbmc_ref <- readRDS("results/R_objects/10X_SingleCellExperiment_clustered.RDS")

# Filter to keep only fresh cells from male
pbmc_ref <- pbmc_ref[, pbmc_ref$sex == "male" & pbmc_ref$time == "0h"]

# Calculate time-score for every cell in SCE
pbmc_ref_list <- list()
cell_types <- names(metasignature)
for (type in cell_types) {
  pbmc_ref_list[[type]] <- pbmc_ref[, pbmc_ref$cell_type == type]
}
pbmc_ref_list <- map2(
  pbmc_ref_list, rankings_dfs, 
  ~ calc_time_score_v3(sce = .x, signature_df = .y, random = FALSE)
)

# Input time-score to original SCE
cell_names_sce <- map(pbmc_ref_list, colnames)
cell_names_sce <- Reduce(c, cell_names_sce)
time_scores <- map(pbmc_ref_list, ~ .$time_score)
time_scores <- Reduce(c, time_scores)
time_score_df <- data.frame(barcode = cell_names_sce, time_score = time_scores)
rownames(time_score_df) <- time_score_df$barcode
time_score_df <- time_score_df[colnames(pbmc_ref), ]
pbmc_ref$time_score <- time_score_df$time_score

# Convert to Seurat object and pre-process
pbmc_ref_seu <- as.Seurat(pbmc_ref)
pbmc_ref_seu <- FindVariableFeatures(pbmc_ref_seu)
pbmc_ref_seu <- ScaleData(pbmc_ref_seu)
pbmc_ref_seu <- RunPCA(pbmc_ref_seu)
ElbowPlot(pbmc_ref_seu)
pbmc_ref_seu <- RunUMAP(pbmc_ref_seu, dims = 1:8, reduction = "pca")
umap_ref_gg <- FeaturePlot(
  pbmc_ref_seu, 
  features = "time_score", 
  reduction = "umap"
)
umap_ref_gg <- umap_ref_gg + 
  scale_colour_gradient2() +
  labs(title = "Reference dataset")

# Arrange and save umaps
umap_external_gg <- FeaturePlot(pbmc_seu, features = "time_score") + 
  scale_colour_gradient2() +
  labs(title = "External dataset")
joint_gg <- ggarrange(
  plotlist = list(umap_external_gg, umap_ref_gg), 
  ncol = 2, 
  nrow = 1, 
  common.legend = TRUE
)
ggsave(
  filename = "results/plots/time_score_external&reference.pdf", 
  plot = joint_gg, 
  width = 12, 
  height = 8
)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
