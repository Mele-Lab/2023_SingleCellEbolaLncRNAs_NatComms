---
title: "Sc analysis"
author: "Luisa Santus"
date: "1/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(Seurat)
library(Matrix)
library(scater)
library(SingleCellExperiment)
library(purrr)
library(stringr)
library(mvoutlier)
library(dropbead)
library(scater)
library(stringr)
library(scran)
library(cowplot)


source("utils/sc_utils.R")
```
## Single Cell Analysis

------------------------
  Create Seurat Objects
------------------------

I import the data and merge them into one single Seurat object to proceed with the analysis.

```{r cars}
# Load the PBMC dataset
data_dir <- "/home/luisas/Desktop/cluster/data/01_Ebola-RNASeq/03_scRNA-Seq_test/01_digital_expression/"
files <- iterate_files(data_dir, ".dge.txt.gz")

files_reads <- files[str_detect(files, "reads" )]
files_umis <- files[!str_detect(files, "reads" )]

# ----------------------
# Obtain Seurat Objects 
# ----------------------
get_Seurat_object <- function(file){
  pbmc.data <- read.table(file = file, header = TRUE, row.names = 1)
  proj <-str_replace_all(str_replace_all(unlist(rev(unlist(str_split(file, pattern= "/"))[-1])[[1]]), "_", "-"), ".dge.txt.gz", "")
  proj <- str_sub(proj, 1, str_length(proj)-3)
  pbmc <- CreateSeuratObject(pbmc.data, project = proj, min.cells = 3, min.features = 200)
  return(pbmc)
}

# Umis 
# all matrices files from single cell, still separated per lane
list <- map(files_umis[2:length(files_umis)], get_Seurat_object)
pbmc <- get_Seurat_object(files_umis[1])
list_names <- lapply(files_umis, function(x) str_replace_all(unlist(rev(unlist(str_split(x, pattern= "/"))[-1])[[1]]), "_", "-"))

# -------------
#   Merge
# -------------
# Merge all seurats object in one 
pbmc.big <- merge(pbmc, y = list, add.cell.ids = list_names, project = "PBMCbig")
# Check if all ids available
unique(sapply(X = strsplit(colnames(pbmc.big), split = "_"), FUN = "[", 1))
table(pbmc.big$orig.ident)


saveRDS(pbmc.big, "results/ed_seurat_tagged_umis.rds")
```
##----------------------------
##           Cell QC 
##----------------------------  
```{r pressure, results='hide', message=FALSE, warning=FALSE}
pbmc.big <- readRDS("results/ed_seurat_umis.rds")
pbmc_sc <- as.SingleCellExperiment(pbmc.big)
pbmc_sc <- calculateQCMetrics(pbmc_sc)

# Library size
lib_size_hist <- plot_histogram(
  sce = pbmc_sc, 
  qc_metric = "total_counts", 
  title = "Library Size (total UMI)", 
  log_scale = TRUE
)

# Number of detected genes
n_detec_hist <- plot_histogram(
  sce = pbmc_sc, 
  qc_metric = "total_features_by_counts", 
  title = "Number of detected genes", 
  log_scale = FALSE
)


lsizeplot <- lib_size_hist +
  geom_vline(xintercept = c(500, 10000), linetype = "dashed", color = "red")
ndectplot <- n_detec_hist +
  geom_vline(xintercept = c(300, 2000), linetype = "dashed", color = "red")

lsizeplot
ndectplot
```
# Filtering 

```{r}
pbmc <- pbmc_sc
keep_cells <-
  pbmc$total_counts > 500 & pbmc$total_counts < 10000 &
  pbmc$total_features_by_counts > 300 & pbmc$total_features_by_counts < 2000 
table(keep_cells)
```

Let us assess if poor-quality cells cluster together

```{r}
pbmc <- runTSNE(pbmc, exprs_values = "counts")
pbmc$poor_quality <- !keep_cells
tsne_poor <- reducedDim(pbmc) %>% 
  as.data.frame() %>% 
  set_names(c("tSNE1", "tSNE2")) %>% 
  mutate(is_poor_quality = pbmc$poor_quality) %>% 
  ggplot(aes(tSNE1, tSNE2, color = is_poor_quality)) +
    geom_point() +
    scale_color_manual("lysed cells", values = c("gray62", "red2")) +
    theme_classic2()
tsne_poor
```

Filter cells:

```{r}
pbmc <- pbmc[, keep_cells]
```

##----------------------------
##           Gene QC 
##----------------------------  
Let us compute the number of cells that each gene has at least 1 UMI:

```{r}
n_cells <- rowSums(as.matrix(counts(pbmc)) > 0)
gene_qc_gg <- n_cells %>% 
  as.data.frame() %>% 
  ggplot(aes(n_cells)) + 
    geom_histogram(bins = 100, alpha = 0.75) +
    scale_x_log10("log10(Number of cells)") +
    theme_bw() 
gene_qc_gg
```

We see two peaks, the firt one of which corresponds to lowly expressed genes. As explained in [Luecken MD et al.](https://www.embopress.org/doi/pdf/10.15252/msb.20188746): "a guideline to setting this threshold is to use the minimum cell cluster size that is of interest and leaving some leeway for dropout effects". As we will not rely on clusters that have fewer than 15 cells, we will use it as a filter:

```{r}
pbmc <- pbmc[n_cells > 15, ]
saveRDS(pbmc, "results/ed_seurat_umis_afterqc.rds")
```

##-------------------------------------------------------------------------------
##    Doublet Detection ( after QC! should not be applied on integrated data ) Needs to be tested !!!
##-------------------------------------------------------------------------------

```{r cars}
library(DoubletFinder)
library(SingleCellExperiment)
library(DoubletDecon)
## Test 
pbmc <- seu_kidney <- get_Seurat_object(files_umis[1])
pbmc <- pbmc[,1:100]
sce <- as.SingleCellExperiment(pbmc)
pbmc <- SCTransform(pbmc)
pbmc <- RunPCA(pbmc)
pbmc <- RunTSNE(pbmc)
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)

DimPlot(pbmc, reduction = "tsne")
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)

new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", "CD8 T", "FCGR3A+ Mono", 
    "NK", "DC", "A")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "tsne", label = TRUE, pt.size = 0.5) + NoLegend()
pbmc$celltype <- Idents(object = pbmc)
head(x = Idents(object = pbmc))
Improved_Seurat_Pre_Process(pbmc, num_genes=50, write_files=FALSE)
WhichCells.Seurat(object = pbmc, idents = ident.1)

# Preprocessing 
seu_kidney <- get_Seurat_object(files_umis[1])
seu_kidney <- SCTransform(seu_kidney)
seu_kidney <- RunPCA(seu_kidney)
seu_kidney <- RunTSNE(seu_kidney)

sce <- as.SingleCellExperiment(seu_kidney)
clust.kmeans <- kmeans(reducedDim(sce, "PCA"), centers=6)
table(clust.kmeans$cluster)

sce$cluster <- factor(clust.kmeans$cluster)
plotReducedDim(sce, "TSNE", colour_by="cluster", text_by = "cluster")



library(BiocSingular)
set.seed(100)

# Setting up the parameters for consistency with denoisePCA();
# this can be changed depending on your feature selection scheme.
dbl.dens <- doubletCells(sce, d=ncol(reducedDim(sce)))
summary(dbl.dens)

sce$DoubletScore <- log10(dbl.dens+1)
plotTSNE(sce, colour_by="DoubletScore")


dbl.out <- doubletCluster(sce, sce$cluster)

chosen.doublet <- rownames(dbl.out)[isOutlier(dbl.out$N, type="lower", log=TRUE)]
chosen.doublet

markers <- findMarkers(sce, sce$cluster, direction="up")
dbl.markers <- markers[[chosen.doublet]]

chosen <- rownames(dbl.markers)[dbl.markers$Top <= 10]
plotHeatmap(sce, order_columns_by="cluster", features=chosen, 
    center=TRUE, symmetric=TRUE, zlim=c(-5, 5))

plotExpression(sce, features=c("ENSMMUG00000041831--HBB", "ENSMMUG00000013966--LGMN"), 
    x="cluster", colour_by="cluster")
```


##-------------------------------------------------------------------------------
##                         Stimulated data analysis 
##-------------------------------------------------------------------------------
```{r cars}
pbmc <- readRDS( "results/ed_seurat_umis_afterqc.rds")
pbmc <- as.Seurat(pbmc)
## Add condition 
pbmc$cond <- unlist(lapply(pbmc$orig.ident, function(x) unlist(str_split(x, "-")[[1]][2])))
table(pbmc$cond)
pbmc$hour <- unlist(lapply(pbmc$orig.ident, function(x) unlist(str_split(x, "-")[[1]][5])))
table(pbmc$hour)
# Create different object, one for wach condition
pbmc <- SplitObject(pbmc, split.by = "cond")
pbmc <- lapply(X = pbmc, FUN = function(x) {
    x <- NormalizeData(x)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})
# Find Anchors btw objects
immune.anchors <- FindIntegrationAnchors(object.list = pbmc, dims = 1:4)
# Combne into one object
immune.combined <- IntegrateData(anchorset = immune.anchors, dims = 1:4)
DefaultAssay(immune.combined) <- "integrated"
immune.combined <- ScaleData(immune.combined, verbose = FALSE)
immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE)
# t-SNE and Clustering
immune.combined <- RunUMAP(immune.combined, reduction = "pca", dims = 1:4)
immune.combined <- FindNeighbors(immune.combined, reduction = "pca", dims = 1:4)
immune.combined <- FindClusters(immune.combined, resolution = 0.5)
saveRDS(immune.combined, "results/immune_combined.rds")



immune.combined <- readRDS("results/immune_combined.rds")
p1 <- DimPlot(immune.combined, reduction = "umap", group.by = "cond")
p2 <- DimPlot(immune.combined, reduction = "umap", label = TRUE)
plot_grid(p1, p2)

DimPlot(immune.combined, reduction = "umap", split.by = "cond")


pbmc_seu <- FindVariableFeatures(immune.combined)
pbmc_seu <- ScaleData(pbmc_seu)
pbmc_seu <- RunPCA(pbmc_seu)
ElbowPlot(pbmc_seu)
pbmc_seu <- FindNeighbors(pbmc_seu, reduction = "pca", dims = 1:6)
pbmc_seu <- FindClusters(pbmc_seu, resolution = 0.1)
pbmc_seu <- RunUMAP(pbmc_seu, reduction = "pca", dims = 1:6)
DimPlot(pbmc_seu, reduction = "umap")


markers <- FindAllMarkers(
  immune.combined, 
  features = immune.combined@assays$RNA@var.features, 
  min.pct = 0.25
)

library(dplyr)
map(unique(markers$cluster), function(k) {
  markers %>% 
    dplyr::filter(cluster == k) %>% 
    head(30) %>% 
    select("cluster", "gene", "avg_logFC")
})

immune.combined <- RenameIdents(immune.combined, `0` = "CD14 Mono", `1` = "CD4 Naive T", `2` = "CD4 Memory T", 
    `3` = "CD16 Mono")

DimPlot(immune.combined, label = TRUE)
```


### Identify highly expressed genes
As a validation, let us check whether the highest expressed genes are housekeeping genes like ACTB:

```{r}
plotHighestExprs(pbmc)
```

# Normalization
To normalize for differences in library size and RNA composition, we will use the `scran` package:

```{r}
library(scran)
pbmc <- computeSumFactors(pbmc)
summary(sizeFactors(pbmc))
pbmc <- normalize(pbmc)
assays(pbmc)
logcounts(pbmc)[1:6, 1:6]
plot(sizeFactors(pbmc) ~ pbmc$total_counts)
```

## Save

```{r}
saveRDS(pbmc, "results/external_dataset_SCE.rds")
```

# Seurat

```{r}
# Convert to Seurat object
pbmc_seu <- as.Seurat(pbmc)

# Seurat pre-processing pipeline
pbmc_seu <- FindVariableFeatures(pbmc_seu)
pbmc_seu <- ScaleData(pbmc_seu)
pbmc_seu <- RunPCA(pbmc_seu)
ElbowPlot(pbmc_seu)
pbmc_seu <- FindNeighbors(pbmc_seu, reduction = "pca", dims = 1:6)
pbmc_seu <- FindClusters(pbmc_seu, resolution = 0.1)
pbmc_seu <- RunUMAP(pbmc_seu, reduction = "pca", dims = 1:6)
DimPlot(pbmc_seu, reduction = "umap")

# Save Seurat
saveRDS(pbmc_seu, "results/external_dataset_Seurat.rds")
pbmc_seu <- readRDS("results/external_dataset_Seurat.rds")
```

Find markers:

```{r}
markers <- FindAllMarkers(
  pbmc_seu, 
  features = pbmc_seu@assays$RNA@var.features, 
  min.pct = 0.25
)

library(dplyr)
map(unique(markers$cluster), function(k) {
  markers %>% 
    dplyr::filter(cluster == k) %>% 
    head(30) %>% 
    select("cluster", "gene", "avg_logFC")
})
```

Judging by the previous markers, we can annotate the clusters as follows:

Cluster ID | Markers       | Cell Type
-----------|---------------|----------
0          | IL7R          | CD4 T cells
2          | GNLY, NKG7    | Natural Killer (NK)
3          | LYZ, S100A8   | CD14+ Monocytes
4          | MS4A1  | B cells

We can visualize these markers in UMAP space:

```{r}
clust_markers <- c("ENSMMUG00000001260--MS4A1", "ENSMMUG00000001676--IL7R", "ENSMMUG00000047204--GNLY", "ENSMMUG00000008987--LYZ")
FeaturePlot(pbmc_seu, features = clust_markers, reduction = "umap")
```

Finally, we can label clusters to its cell type:

```{r}
new_cluster_ids <- c("CD4 T", "NK", "CD14+ Mono",  "B")
names(new_cluster_ids) <- levels(pbmc_seu)
pbmc_seu <- RenameIdents(pbmc_seu, new_cluster_ids)
DimPlot(pbmc_seu, reduction = "umap")
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
